/*
 * physics.cpp
 *
 *  Created on: Aug 10, 2013
 *      Author: bhargavvar
 */


#include <iostream>
#include <sstream>
#include <ctime>
#include <cstdlib>
#include <math.h>
#include "physics.h"
#include "terrain.h"
#include "vector3f.h"






#include <GL/glut.h>




using namespace std;


const float fps =100;
const float updt=1/fps;

float timahead =0;

//declaration of material data of the object


//bike object related data and functions
 Object::Object()
{



    onterrainborder=false;

}
 float Object::velocityinX()
 	{
 		return velX;
 	}

 	void Object::setvelocityX(float v)
 	{
 			velX=v;
     }




 	float Object::velocityinY()
 	{
 			return velY;
 	}
 	void Object::setvelocityY(float v)
 	{
 		velY=v;
 	}


 	float Object::velocityinZ()
 	{
 		return velZ;
 	}
 	void Object::setvelocityZ(float v)
 	{
 			velZ=v;
 	}



 	float Object::givbikeangle()
 	{
 		return bikeangle;
 	}

void Object::timeaccumulatorfunc()
{

}
void Object::posupdate()
{


	 maxX= ((int)_Terrain->width()-1)*terrainlfactor-size0;
	 maxZ= ((int)_Terrain->length()-1)*terrainlfactor-size0;
     minX= size0;
     minZ= size0;

    if ( posX<size0 || posZ<size0 || posX>maxX || posZ>maxZ)
    {

    	onterrainborder= true;
    }

    if(posX<size0)
    	if(velX<0)
    		setvelocityX(0);
    if(posZ<size0)
    	if(velZ<0)
    		setvelocityZ(0);


    if(posX>maxX)
    	if(velX>0)
    		setvelocityX(0);
    if(posZ>maxZ)
    	if(velZ>0)
    		setvelocityZ(0);



	posX += velX* updt;
	posZ += velZ* updt;
   if(posY<=_Terrain->getHeight[posX][posZ]){


   if(posY==_Terrain->getHeight[posX][posZ])
   {
	   if(velY<0){
		   setvelocityY(0);
	   }




   }
   else{
	   posY=0;
	   velY=0;
   }
   }
	posY +=velY* updt;



}
void Object::velupdate()
{

	//ob->posX += ((ob->force[0])/(ob->mass))* updt;
	//ob->posX += ((ob->force[1])/(ob->mass))* updt   ;
	velY += Gravity* updt;
	velX += accelerate.x *updt;
	velY += accelerate.y *updt;
	velZ += accelerate.z *updt;

	//ob->posX += ((ob->force[2])/(ob->mass))* updt;


}


void Object::framestime()
{

	float framestart=time(0);
	float timenow=time(0);


	while(true)
	{
	   timeaccumulator +=   timenow-framestart;

	   timenow=time(0);
	   framestart=timenow;

	   if (timeaccumulator > 0.25f)
	   {
		timeaccumulator =.25f;
	   }
	   if(timeaccumulator < updt)
	   {
		   return;
	   }
	      else
	      {
		      posupdate();
		      velupdate();
		      timeaccumulator -= updt;


	          }

	  if(bikeangle <0 )
		  bikeangle=bikeangle+360;
	  if(bikeangle >360)
		  bikeangle=bikeangle-360;



	}
}



