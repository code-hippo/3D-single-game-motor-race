/*
 * terrain.cpp
 *
 *  Created on: 12-Aug-2013
 *      Author: vignan_pc
 */



//converting image to array of information
#include <iostream>
#include <stdlib.h>

#include <GL/glut.h>


#include "readData.h"
#include "vector3f.h"
#include"terrain.h"

using namespace std;



terrain::terrain(int length,int width){
		l=length;
		w=width;


		normals = new vector3f*[l];
		for(int i = 0; i < l; i++) {
			normals[i] = new vector3f[w];
		}


		hs=new float*[l];
		for(int i=0;i<l;i++){
			hs[i]=new float[w];
		}
		normalscomputed=false;
	}

	//Deconstructor

terrain::~terrain(){
		for(int i = 0; i < l; i++) {
					delete[] hs[i];
				}

			delete[] hs;

		for(int i = 0; i < l; i++) {
					delete[] normals[i];
				}

			delete[] normals;
				}

	//Functions on terrain class

int terrain::length(){
		return l;
	}

	int terrain::width(){
		return w;
	}

	void terrain::setHeight(int x, int z, float y) {
				hs[z][x] = y;
				normalscomputed = false;
			}


// computing the normals at every (x,z)

	void terrain::computeNormals() {

			if (normalscomputed) {
					return;
				}


			vector3f** param_norm = new vector3f*[l];
				for(int i = 0; i < l; i++) {
					param_norm[i] = new vector3f[w];
				}

			for(int z = 0; z < l; z++) {
				for(int x = 0; x < w; x++) {
					vector3f avg=setvalues(0.0f, 0.0f, 0.0f);
					vector3f in,out,left,right;

					//computing in
					if (z < l - 1) {
							in = setvalues(0.0f, hs[z + 1][x] - hs[z][x], 1.0f);
					}
					////computing out
					if (z > 0) {
							out = setvalues(0.0f, hs[z - 1][x] - hs[z][x], -1.0f);
					}
					//computing left
					if (x > 0) {
							left =setvalues(-1.0f, hs[z][x - 1] - hs[z][x], 0.0f);
					}

					//computing right

					if (x < w - 1) {
							right = setvalues(1.0f, hs[z][x + 1] - hs[z][x], 0.0f);
					}

					if (x > 0 && z > 0) {
							avg=sum(avg,unitvec(crossproduct(out,left)));
					}
					if (x > 0 && z < l - 1) {
							avg =sum(avg, unitvec(crossproduct(in,left)));
					}
					if (x < w - 1 && z < l - 1) {
							avg = sum(avg,unitvec(crossproduct(right,in)));
					}
					if (x < w - 1 && z > 0) {
							avg = sum(avg,unitvec(crossproduct(out,right)));
					}

					param_norm[z][x] = avg;

			}


	}


			float f=0.5;
			for(int z = 0; z < l; z++) {
					for(int x = 0; x < w; x++) {
						vector3f var = param_norm[z][x];

						if (x > 0) {
							var =sum(var, smulp(param_norm[z][x - 1],f));
							}
						if (x < w - 1) {
							var=sum (var,smulp(param_norm[z][x + 1],f) );
							}
						if (z > 0) {
							var= sum(var,smulp(param_norm[z - 1][x],f));
						}
						if (z < l - 1) {
							var= sum(var,smulp(param_norm[z + 1][x],f));
						}

						if (magnitude(var) == 0) {
							var= setvalues(0.0f, 1.0f, 0.0f);
						}
						normals[z][x] = var;
					}
	}
			for(int i = 0; i < l; i++) {
				delete[] param_norm[i];
				}
				delete[] param_norm;

				normalscomputed = true;
					}
	vector3f terrain::getNormal(int x, int z) {
				if (!normalscomputed) {
					computeNormals();
				}
				return normals[z][x];
			}
	float terrain::getHeight(int x,int z){
		return hs[z][x];
	}

terrain* createTerrain(const char* filename, float height) {
	Image* image = loadImage(filename);
	terrain* t = new terrain(image->width, image->height);
	for(int y = 0; y < image->height; y++) {
		for(int x = 0; x < image->width; x++) {
			unsigned char color =
				(unsigned char)image->pixels[3 * (y * image->width + x)];
			float h = height * ((color / 255.0f) - 0.5f);
			t->setHeight(x, y, h);
		}
	}

	delete image;
	t->computeNormals();
	return t;
}

terrain* _terrain;

void clean() {
	delete _terrain;
}


void initRendering() {
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_COLOR_MATERIAL);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glEnable(GL_NORMALIZE);
	glShadeModel(GL_SMOOTH);
}
void handleKeypress(unsigned char key, int x, int y) {
	if (key==27/*esc*/) {
			clean();
			exit(0);
	}
}

float _angle=45.0;

void drawScene() {
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glTranslatef(0.0f, 0.0f, -10.0f);
	glRotatef(30.0f, 1.0f, 0.0f, 0.0f);
	glRotatef(-_angle, 0.0f, 1.0f, 0.0f);

	GLfloat ambientColor[] = {0.4f, 0.4f, 0.4f, 1.0f};
	glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambientColor);

	GLfloat lightColor0[] = {0.6f, 0.6f, 0.6f, 1.0f};
	GLfloat lightPos0[] = {-1.0f, -1.0f, -1.0f, 1.0f};
	glLightfv(GL_LIGHT0, GL_DIFFUSE, lightColor0);
	glLightfv(GL_LIGHT0, GL_POSITION, lightPos0);

	float scale = 7.0f / max(_terrain->width() - 1, _terrain->length() - 1);
	glScalef(scale, scale, scale);
	glTranslatef(-(float)(_terrain->width() - 1) / 2,
				 0.0f,
				 -(float)(_terrain->length() - 1) / 2);

	glColor3f(  0.65f, 0.5f, 0.39f);
	for(int z = 0; z < _terrain->length() - 1; z++) {

		glBegin(GL_TRIANGLE_STRIP);
		for(int x = 0; x < _terrain->width(); x++) {
			vector3f normal = _terrain->getNormal(x, z);
			glNormal3f(normal.x, normal.y, normal.z);
			glVertex3f(x, _terrain->getHeight(x, z), z);
			normal = _terrain->getNormal(x, z + 1);
			glNormal3f(normal.x, normal.y, normal.z);
			glVertex3f(x, _terrain->getHeight(x, z + 1), z + 1);
		}
		glEnd();
	}

	glutSwapBuffers();
}
void handleResize(int w, int h) {
	glViewport(0, 0, w, h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(45.0, (double)w / (double)h, 1.0, 200.0);
}



























